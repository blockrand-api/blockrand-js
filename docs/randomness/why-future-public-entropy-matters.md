---
title: "Timing Attacks in Randomness: Why Future Public Entropy is the Only Solution"
description: "Most randomness systems fail due to timing, not math. Learn why future public entropy from sources like Drand is essential for truly fair games, lotteries, and verifiable systems."
---

# Why Future Public Entropy Matters: Timing, Bias, and Trust in Randomness Systems

Randomness systems fail not because the math is weak, but because the timing is wrong.

This document explains why future public entropy is critical for fairness, and why many "secure" randomness systems are still manipulable in practice.

## The Core Problem: Who Knows the Randomness First

In any system that generates random outcomes, one question dominates all others:

**Who knew the random value first?**

If the answer is:

* The server
* The game operator
* The contract deployer
* The house

Then the system is not fair, regardless of cryptography.

## Why Strong Randomness Is Not Enough

Developers often rely on:

* Secure PRNGs
* Cryptographic hashes
* OS-level entropy
* Hardware RNGs

These are mathematically strong, but socially weak.

Why?

Because someone knows the output **before** the user commits to an action. That knowledge creates leverage.

## The Timing Attack Most People Miss

Consider this flow:

1. Server generates a random value
2. Server asks the player to act
3. Server applies the random outcome

Even if the random value is cryptographically perfect, the server can:

* Abort unfavorable outcomes
* Retry silently
* Delay responses
* Selectively reveal

None of this breaks cryptography. All of it breaks fairness.

## Why Commit-Reveal Alone Is Not Sufficient

Commit-reveal helps, but only partially.

If both sides commit to secrets that already exist, then:

* Both sides already know their inputs
* The combined result is already determined
* One side may still have informational advantage

The missing ingredient is unpredictability at commit time.

## What Future Entropy Solves

Future entropy means:

* The random source does not exist yet
* Nobody can know it at commit time
* Nobody can bias it retroactively

This changes the power balance completely. Both sides commit blind.

## Public vs Private Future Entropy

**Private future entropy:**

* Generated by the server later
* Requires trust
* Cannot be independently verified

**Public future entropy:**

* Generated by an external network
* Timestamped
* Widely observed
* Independently auditable

Only public future entropy removes trust from the equation.

## Why Blockchains Were Used (And Their Limits)

Blockchains introduced a powerful idea: **Future block hashes are unknowable at commit time.**

This was a major step forward.

However, blockchains have drawbacks:

* Variable timing
* Long confirmation delays
* Miner influence in edge cases
* High latency for games

They are fair, but not always practical.

## Why Drand Is a Better Fit for Games

Drand provides:

* Public randomness
* Fixed-time rounds
* Threshold signatures
* No single controlling party
* Sub-minute predictability windows

Most importantly:

* The value does not exist before the round
* The signature proves correctness
* Anyone can verify independently

This makes drand ideal for interactive systems.

## Why "Latest Randomness" Is Not Safe

Some systems use: **"The most recent randomness available"**

This is dangerous.

If randomness already exists:

* Someone has seen it
* Someone can condition behavior on it
* Someone can delay or front-run

Only future rounds provide real fairness.

## The Correct Fairness Timeline

A fair system looks like this:

1. Player commits (hash only)
2. Server commits (hash only)
3. Future public entropy is selected
4. Entropy becomes available
5. Secrets are revealed
6. Final randomness is computed using the secrets already committed.

At no point does anyone know the outcome early.
This is how [BlockRand](https://github.com/blockrand-api/blockrand-js) generates all its Random Numbers.

## Why Delay Is a Feature, Not a Bug

Waiting is uncomfortable, but necessary.

The delay:

* Removes informational advantage
* Prevents outcome steering
* Enforces symmetry
* Creates trust through constraint

Systems that promise "instant fairness" usually hide a shortcut.

## How to Avoid Waiting Without Cheating

Advanced systems solve this by:

* Reusing the last fully verified seed
* Locking future outcomes to it
* Publishing deterministic derivations
* Switching seeds only after verification

This preserves fairness while keeping UX smooth.

## Key Takeaway

Fair randomness is not about stronger math. It is about weaker assumptions.

If nobody can know the result early, nobody can cheat.

Future public entropy enforces that rule mechanically.

That is why it matters.
